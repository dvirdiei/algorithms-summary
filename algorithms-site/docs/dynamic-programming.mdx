---
id: dynamic-programming
title: תכנון דינמי
description: טכניקה לפתרון בעיות אופטימיזציה באמצעות זיכרון ומבנה רקורסיבי
sidebar_label: תכנון דינמי (Dynamic Programming)
---

<div className="greedyDoc container">
  <p className="greedyDoc__badge">Dynamic Programming</p>
  <h1>תכנון דינמי</h1>
  <p className="greedyDoc__lead">
    תכנון דינמי הוא טכניקה חזקה לפתרון בעיות אופטימיזציה. הרעיון המרכזי: במקום לפתור את אותה 
    תת-בעיה שוב ושוב, נפתור אותה פעם אחת ונשמור את התוצאה. כך נמנע חישובים מיותרים ונמיר 
    פתרונות אקספוננציאליים לפולינומיים. זו שיטת "זכור ולא תחשב מחדש" שמאפשרת לפתור בעיות 
    שנראות בלתי אפשריות בזמן סביר.
  </p>
  <ul className="greedyDoc__tags">
    <li>Memoization</li>
    <li>Optimal Substructure</li>
    <li>Overlapping Subproblems</li>
  </ul>
</div>

<figure className="conceptStory container" aria-label="מחשב שזוכר תוצאות קודמות">
  <div className="conceptStory__canvas">
    <svg viewBox="0 0 600 280" role="img">
      <defs>
        <linearGradient id="dpBg" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stopColor="#1a2d4d" />
          <stop offset="100%" stopColor="#0d1a30" />
        </linearGradient>
        <radialGradient id="memoryGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" stopColor="#64f6c8" stopOpacity="0.9" />
          <stop offset="100%" stopColor="#64f6c8" stopOpacity="0" />
        </radialGradient>
        <linearGradient id="tableGradient" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stopColor="#a78bfa" />
          <stop offset="100%" stopColor="#64f6c8" />
        </linearGradient>
        <filter id="dpShadow">
          <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <rect width="600" height="280" fill="url(#dpBg)" rx="16" />

      {/* טבלת DP */}
      <g opacity="0.9">
        <rect x="50" y="40" width="500" height="180" fill="rgba(100, 246, 200, 0.1)" 
              stroke="#64f6c8" strokeWidth="2" rx="8" />
        
        {/* תאי הטבלה */}
        {[...Array(5)].map((_, i) => [...Array(8)].map((_, j) => {
          const filled = (i * 8 + j) < 25;
          return (
            <g key={`${i}-${j}`}>
              <rect 
                x={70 + j * 58} 
                y={60 + i * 32} 
                width={50} 
                height={28} 
                fill={filled ? "rgba(167, 139, 250, 0.3)" : "rgba(255,255,255,0.05)"} 
                stroke={filled ? "#a78bfa" : "#3d4d6b"} 
                strokeWidth="1.5" 
                rx="4"
              />
              {filled && (
                <text 
                  x={95 + j * 58} 
                  y={78 + i * 32} 
                  fill="#fbbf24" 
                  fontSize="11" 
                  fontWeight="bold" 
                  textAnchor="middle"
                >
                  {Math.floor(Math.random() * 20)}
                </text>
              )}
            </g>
          );
        }))}

        {/* חץ שמראה מילוי הדרגתי */}
        <path 
          d="M 60 235 L 540 235" 
          stroke="#64f6c8" 
          strokeWidth="3" 
          markerEnd="url(#arrow)" 
          strokeDasharray="8,4"
        />
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <polygon points="0 0, 10 3, 0 6" fill="#64f6c8" />
          </marker>
        </defs>
        <text x="300" y="260" fill="#64f6c8" fontSize="13" fontWeight="bold" textAnchor="middle">
          מילוי הדרגתי: כל תא נשען על תאים שכבר חושבו
        </text>
      </g>

      {/* איקון זיכרון */}
      <g transform="translate(480, 30)">
        <circle cx="50" cy="30" r="35" fill="url(#memoryGlow)" opacity="0.7">
          <animate attributeName="opacity" values="0.5;0.9;0.5" dur="2s" repeatCount="indefinite" />
        </circle>
        <path d="M 35 20 L 35 40 L 65 40 L 65 20 Z" fill="#fbbf24" opacity="0.8" />
        <path d="M 40 25 L 40 35 M 50 25 L 50 35 M 60 25 L 60 35" 
              stroke="#000" strokeWidth="2" />
        <text x="50" y="55" fill="#fbbf24" fontSize="10" fontWeight="bold" textAnchor="middle">
          MEMO
        </text>
      </g>
    </svg>
  </div>
  <figcaption className="conceptStory__caption">
    <h4>זיכרון וחיסכון בחישובים</h4>
    <p>
      תכנון דינמי בונה טבלה שבה כל תא מייצג פתרון לתת-בעיה. כל תא חדש מחושב 
      רק פעם אחת על בסיס תאים שכבר חושבו. זה מונע חישובים כפולים והופך בעיות 
      מסובכות לפתירות.
    </p>
    <ul>
      <li><strong>מילוי הדרגתי:</strong> פותרים תתי-בעיות קטנות לפני הגדולות</li>
      <li><strong>שימוש חוזר:</strong> כל תוצאה נשמרת ונמשכת בלי חישוב נוסף</li>
      <li><strong>מבנה אופטימלי:</strong> הפתרון האופטימלי בנוי מפתרונות אופטימליים קטנים יותר</li>
    </ul>
  </figcaption>
</figure>

<section className="conceptGrid container">
  <article className="conceptCard conceptCard--explain">
    <p className="conceptCard__label">בעיה</p>
    <h3 className="conceptCard__title">למה צריך תכנון דינמי?</h3>
    <p className="conceptCard__body">
      <strong>שאלה:</strong> איך פותרים בעיות אופטימיזציה מורכבות? <br/>
      <strong>בעיה קלאסית:</strong> רקורסיה פשוטה פותרת את אותן תתי-בעיות שוב ושוב.
      לדוגמה, חישוב פיבונאצ'י F(5) דורש חישוב של F(3) פעמיים! <br/>
      <strong>תוצאה:</strong> סיבוכיות אקספוננציאלית O(2ⁿ) שהופכת בעיות לבלתי פתירות אפילו עבור n קטן.
    </p>
  </article>
  <article className="conceptCard conceptCard--algorithm">
    <p className="conceptCard__label">רעיון</p>
    <h3 className="conceptCard__title">שתי תכונות הכרחיות</h3>
    <p className="conceptCard__body">
      <strong>1. Overlapping Subproblems:</strong> אותן תתי-בעיות חוזרות שוב ושוב.
      במקום לפתור כל פעם מחדש, נזכור את התשובה בטבלה.
      <br/><br/>
      <strong>2. Optimal Substructure:</strong> הפתרון האופטימלי לבעיה בנוי מפתרונות 
      אופטימליים לתתי-בעיות. אם F(n) אופטימלי, הוא חייב להיבנות מ-F(n-1) ו-F(n-2) האופטימליים.
    </p>
  </article>
  <article className="conceptCard conceptCard--solution">
    <p className="conceptCard__label">פתרון</p>
    <h3 className="conceptCard__title">שתי גישות מרכזיות</h3>
    <p className="conceptCard__body">
      <strong>Top-Down (Memoization):</strong> רקורסיה + טבלת זיכרון. כשפותרים תת-בעיה, 
      שומרים את התוצאה. בפעם הבאה, מחזירים מהטבלה במקום לחשב מחדש.
      <br/><br/>
      <strong>Bottom-Up (Tabulation):</strong> מילוי טבלה איטרטיבי מהתתי-בעיות הקטנות 
      ביותר עד לבעיה המקורית. סדר המילוי חייב לכבד תלויות בין התאים.
    </p>
  </article>
</section>

<section id="core-concepts" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">מושגי יסוד</p>
    <h2>מה צריך להבין לפני שמתחילים?</h2>
  </header>
  <div className="conceptGrid">
    <article className="conceptCard conceptCard--insight">
      <p className="conceptCard__label">הגדרת מצב</p>
      <h3 className="conceptCard__title">State Definition</h3>
      <p className="conceptCard__body">
        כל תא בטבלה מייצג <strong>מצב</strong> - קבוצת פרמטרים שמגדירים תת-בעיה ייחודית.
        <br/><br/>
        <strong>דוגמה:</strong> בבעיית התרמיל, dp[i][w] = הערך המקסימלי שניתן להשיג 
        עם i פריטים ראשונים וקיבולת w.
        <br/><br/>
        <strong>חשוב:</strong> הגדרה לא ברורה של המצב = קוד שגוי!
      </p>
    </article>
    <article className="conceptCard conceptCard--insight">
      <p className="conceptCard__label">מעבר</p>
      <h3 className="conceptCard__title">Transition / Recurrence</h3>
      <p className="conceptCard__body">
        הקשר בין מצב נוכחי למצבים קודמים. איך מחשבים dp[i] על בסיס dp[i-1], dp[i-2] וכו'?
        <br/><br/>
        <strong>דוגמה פיבונאצ'י:</strong> F(n) = F(n-1) + F(n-2)
        <br/>
        <strong>דוגמה תרמיל:</strong> 
        <br/>
        dp[i][w] = max(dp[i-1][w], value[i] + dp[i-1][w-weight[i]])
        <br/><br/>
        המעבר הוא הלב של DP!
      </p>
    </article>
    <article className="conceptCard conceptCard--insight">
      <p className="conceptCard__label">תנאי בסיס</p>
      <h3 className="conceptCard__title">Base Cases</h3>
      <p className="conceptCard__body">
        המקרים הפשוטים ביותר שאפשר לפתור ישירות, בלי להסתמך על תתי-בעיות אחרות.
        <br/><br/>
        <strong>דוגמה פיבונאצ'י:</strong> F(0) = 0, F(1) = 1
        <br/>
        <strong>דוגמה תרמיל:</strong> dp[0][w] = 0 לכל w (אין פריטים = אין ערך)
        <br/><br/>
        בסיסים שגויים → כל הטבלה שגויה!
      </p>
    </article>
    <article className="conceptCard conceptCard--important">
      <p className="conceptCard__label">סדר חישוב</p>
      <h3 className="conceptCard__title">Order of Computation</h3>
      <p className="conceptCard__body">
        בגישת Bottom-Up, חייבים למלא את הטבלה בסדר כזה שכל תא שאנחנו צריכים 
        כבר חושב לפני שאנחנו משתמשים בו.
        <br/><br/>
        <strong>טיפ:</strong> אם dp[i] תלוי ב-dp[i-1], מלאו מ-0 ל-n.
        <br/>
        אם dp[i][j] תלוי ב-dp[i-1][j-1], מלאו שורה אחר שורה.
        <br/><br/>
        סדר שגוי = שימוש בערכים לא מאותחלים!
      </p>
    </article>
  </div>
</section>

<section id="fibonacci-example" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">דוגמה 1: פיבונאצ'י</p>
    <h2>הדוגמה הקלאסית לתכנון דינמי</h2>
  </header>
  <div style={{ display: 'flex', gap: '2rem', alignItems: 'flex-start' }}>
    <div style={{ flex: '0 0 400px' }}>
      <svg viewBox="0 0 400 600" style={{ width: '100%', height: 'auto', background: 'rgba(0,0,0,0.1)', borderRadius: '12px', padding: '1rem' }}>
        <defs>
          <filter id="fibGlow">
            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>

        {/* רקורסיה נאיבית - עץ */}
        <text x="200" y="25" fill="#f97316" fontSize="16" fontWeight="bold" textAnchor="middle">
          רקורסיה נאיבית: O(2ⁿ)
        </text>
        <rect x="10" y="35" width="380" height="2" fill="#f97316" opacity="0.3" />

        {/* עץ רקורסיה */}
        <circle cx="200" cy="70" r="20" fill="#f97316" stroke="#fff" strokeWidth="2" filter="url(#fibGlow)" />
        <text x="200" y="77" fill="#fff" fontSize="12" fontWeight="bold" textAnchor="middle">F(5)</text>

        <line x1="185" y1="85" x2="140" y2="115" stroke="#f97316" strokeWidth="2" />
        <line x1="215" y1="85" x2="260" y2="115" stroke="#f97316" strokeWidth="2" />

        <circle cx="140" cy="130" r="18" fill="#f97316" stroke="#fff" strokeWidth="2" />
        <text x="140" y="136" fill="#fff" fontSize="11" fontWeight="bold" textAnchor="middle">F(4)</text>

        <circle cx="260" cy="130" r="18" fill="#f97316" stroke="#fff" strokeWidth="2" />
        <text x="260" y="136" fill="#fff" fontSize="11" fontWeight="bold" textAnchor="middle">F(3)</text>

        <line x1="127" y1="145" x2="100" y2="170" stroke="#f97316" strokeWidth="1.5" />
        <line x1="153" y1="145" x2="180" y2="170" stroke="#f97316" strokeWidth="1.5" />
        <line x1="247" y1="145" x2="220" y2="170" stroke="#f97316" strokeWidth="1.5" />
        <line x1="273" y1="145" x2="300" y2="170" stroke="#f97316" strokeWidth="1.5" />

        <circle cx="100" cy="185" r="16" fill="#f97316" stroke="#fff" strokeWidth="2" />
        <text x="100" y="191" fill="#fff" fontSize="10" fontWeight="bold" textAnchor="middle">F(3)</text>

        <circle cx="180" cy="185" r="16" fill="#0d8bd4" stroke="#fff" strokeWidth="2" />
        <text x="180" y="191" fill="#fff" fontSize="10" fontWeight="bold" textAnchor="middle">F(2)</text>

        <circle cx="220" cy="185" r="16" fill="#0d8bd4" stroke="#fff" strokeWidth="2" />
        <text x="220" y="191" fill="#fff" fontSize="10" fontWeight="bold" textAnchor="middle">F(2)</text>

        <circle cx="300" cy="185" r="16" fill="#088a7b" stroke="#fff" strokeWidth="2" />
        <text x="300" y="191" fill="#fff" fontSize="10" fontWeight="bold" textAnchor="middle">F(1)</text>

        <text x="200" y="220" fill="#f97316" fontSize="11" textAnchor="middle">
          F(3) מחושב 2 פעמים! F(2) מחושב 3 פעמים!
        </text>

        {/* חץ למטה */}
        <path d="M 200 230 L 200 270" stroke="#64f6c8" strokeWidth="3" markerEnd="url(#arrowFib)" />
        <defs>
          <marker id="arrowFib" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
            <polygon points="0 0, 10 5, 0 10" fill="#64f6c8" />
          </marker>
        </defs>

        {/* DP - טבלה */}
        <text x="200" y="295" fill="#64f6c8" fontSize="16" fontWeight="bold" textAnchor="middle">
          תכנון דינמי: O(n)
        </text>
        <rect x="10" y="305" width="380" height="2" fill="#64f6c8" opacity="0.3" />

        <g transform="translate(50, 320)">
          {[0, 1, 1, 2, 3, 5].map((val, i) => (
            <g key={i}>
              <rect 
                x={i * 50} 
                y="0" 
                width="45" 
                height="50" 
                fill="rgba(100, 246, 200, 0.2)" 
                stroke="#64f6c8" 
                strokeWidth="2" 
                rx="4"
              />
              <text 
                x={i * 50 + 22} 
                y="25" 
                fill="#fff" 
                fontSize="10" 
                textAnchor="middle"
              >
                F({i})
              </text>
              <text 
                x={i * 50 + 22} 
                y="42" 
                fill="#fbbf24" 
                fontSize="14" 
                fontWeight="bold" 
                textAnchor="middle"
              >
                {val}
              </text>
            </g>
          ))}
        </g>

        <text x="200" y="395" fill="#64f6c8" fontSize="11" textAnchor="middle">
          כל ערך מחושב פעם אחת בלבד!
        </text>

        {/* קוד פסאודו */}
        <rect x="20" y="415" width="360" height="160" fill="rgba(0,0,0,0.3)" stroke="#a78bfa" strokeWidth="2" rx="8" />
        <text x="200" y="435" fill="#a78bfa" fontSize="13" fontWeight="bold" textAnchor="middle">
          Bottom-Up Approach
        </text>
        <text x="35" y="460" fill="#64f6c8" fontSize="11" fontFamily="monospace">
          dp[0] = 0
        </text>
        <text x="35" y="478" fill="#64f6c8" fontSize="11" fontFamily="monospace">
          dp[1] = 1
        </text>
        <text x="35" y="496" fill="#fbbf24" fontSize="11" fontFamily="monospace">
          for i = 2 to n:
        </text>
        <text x="50" y="514" fill="#fbbf24" fontSize="11" fontFamily="monospace">
            dp[i] = dp[i-1] + dp[i-2]
        </text>
        <text x="35" y="532" fill="#64f6c8" fontSize="11" fontFamily="monospace">
          return dp[n]
        </text>
        <text x="200" y="560" fill="#a78bfa" fontSize="10" textAnchor="middle">
          זמן: O(n), זיכרון: O(n) → ניתן לשפר ל-O(1)!
        </text>
      </svg>
    </div>

    <article style={{ flex: '1' }}>
      <p>
        <strong>בעיה:</strong> חשב את המספר ה-n בסדרת פיבונאצ'י
      </p>
      <p>
        <strong>הגדרה:</strong> F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)
      </p>

      <p>
        <strong>למה רקורסיה נאיבית איטית?</strong>
      </p>
      <ul>
        <li>F(5) קורא ל-F(4) ו-F(3)</li>
        <li>F(4) קורא שוב ל-F(3) ו-F(2)</li>
        <li>F(3) מחושב 2 פעמים!</li>
        <li>F(2) מחושב 3 פעמים!</li>
        <li>סה"כ: O(2ⁿ) קריאות - לא סביר כבר ב-n=40</li>
      </ul>

      <p>
        <strong>פתרון DP:</strong>
      </p>
      <ul>
        <li>נצור טבלה dp מגודל n+1</li>
        <li>נאתחל: dp[0] = 0, dp[1] = 1</li>
        <li>נמלא מ-2 עד n: dp[i] = dp[i-1] + dp[i-2]</li>
        <li>נחזיר dp[n]</li>
      </ul>

      <p>
        <strong>למה זה עובד?</strong>
      </p>
      <ul>
        <li>כל ערך מחושב פעם אחת בדיוק</li>
        <li>n איטרציות, כל אחת O(1)</li>
        <li>סה"כ: O(n) זמן במקום O(2ⁿ)!</li>
      </ul>

      <p>
        <strong>אופטימיזציה נוספת:</strong>
      </p>
      <p>
        שימו לב: בכל שלב אנחנו צריכים רק את שני הערכים האחרונים! 
        לכן ניתן להשתמש בשני משתנים בלבד במקום מערך, ולהוריד את הזיכרון ל-O(1).
      </p>
    </article>
  </div>
</section>

<section id="knapsack-example" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">דוגמה 2: תרמיל 0/1</p>
    <h2>בעיית האופטימיזציה הקלאסית</h2>
  </header>
  <div className="greedyDoc__media">
    <article>
      <p>
        <strong>בעיה:</strong> יש לנו תרמיל בקיבולת W ו-n פריטים. לכל פריט i יש משקל weight[i] 
        וערך value[i]. מטרה: למקסם את סכום הערכים מבלי לחרוג מהקיבולת.
      </p>
      <p>
        <strong>מגבלה:</strong> כל פריט אפשר לקחת או לא לקחת (0/1), אי אפשר לקחת חצי פריט.
      </p>

      <div style={{ margin: '2rem 0' }}>
        <table className="greedyDoc__table">
          <thead>
            <tr>
              <th>פריט</th>
              <th>משקל</th>
              <th>ערך</th>
              <th>ערך/משקל</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td>2</td>
              <td>3</td>
              <td>1.5</td>
            </tr>
            <tr>
              <td>2</td>
              <td>3</td>
              <td>4</td>
              <td>1.33</td>
            </tr>
            <tr>
              <td>3</td>
              <td>4</td>
              <td>5</td>
              <td>1.25</td>
            </tr>
            <tr>
              <td>4</td>
              <td>5</td>
              <td>6</td>
              <td>1.2</td>
            </tr>
          </tbody>
        </table>
        <p><strong>קיבולת תרמיל:</strong> W = 8</p>
      </div>

      <p>
        <strong>למה גישה חמדנית לא עובדת?</strong>
      </p>
      <ul>
        <li>אם נקח את הפריט עם הערך הגבוה ביותר (6), נישאר עם קיבולת 3 → ערך כולל = 6+4 = 10</li>
        <li>אם נקח לפי יחס ערך/משקל: פריט 1 (2kg, 3$) + פריט 2 (3kg, 4$) = 5kg, אבל פריט 3 לא נכנס</li>
        <li>הפתרון האופטימלי: פריטים 2+3 (7kg, 9$) או לבדוק כל אפשרות</li>
        <li><strong>מסקנה:</strong> צריך לבדוק את כל האפשרויות בצורה חכמה!</li>
      </ul>

      <p>
        <strong>הגדרת מצב DP:</strong>
      </p>
      <p>
        dp[i][w] = הערך המקסימלי שניתן להשיג כאשר:
      </p>
      <ul>
        <li>i = מספר הפריטים הראשונים שאנחנו שוקלים (0 עד n)</li>
        <li>w = קיבולת זמינה (0 עד W)</li>
      </ul>

      <p>
        <strong>מעבר (Recurrence):</strong>
      </p>
      <p>
        לכל פריט i יש שתי אפשרויות:
      </p>
      <ol>
        <li><strong>לא לקחת אותו:</strong> dp[i][w] = dp[i-1][w]</li>
        <li><strong>לקחת אותו</strong> (רק אם weight[i] ≤ w): 
            dp[i][w] = value[i] + dp[i-1][w - weight[i]]</li>
      </ol>
      <p>
        נבחר את המקסימום:
      </p>
      <p style={{ 
        background: 'rgba(100, 246, 200, 0.1)', 
        padding: '1rem', 
        borderRadius: '8px', 
        borderLeft: '4px solid #64f6c8',
        direction: 'ltr',
        textAlign: 'center',
        fontSize: '1.1em',
        fontWeight: 'bold',
        margin: '1rem 0'
      }}>
        dp[i][w] = max(dp[i-1][w], value[i] + dp[i-1][w-weight[i]])
      </p>

      <p>
        <strong>בסיסים:</strong>
      </p>
      <ul>
        <li>dp[0][w] = 0 לכל w (אין פריטים → אין ערך)</li>
        <li>dp[i][0] = 0 לכל i (אין קיבולת → אין ערך)</li>
      </ul>

      <p>
        <strong>סדר מילוי:</strong>
      </p>
      <p>
        נמלא את הטבלה שורה אחר שורה (i מ-1 עד n), ובכל שורה מימין לשמאל או משמאל לימין (w מ-0 עד W).
      </p>

      <div style={{ margin: '2rem 0' }}>
        <svg viewBox="0 0 700 400" style={{ width: '100%', height: 'auto', background: 'rgba(0,0,0,0.1)', borderRadius: '12px', padding: '1rem' }}>
          <defs>
            <filter id="tableGlow">
              <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
              <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>

          <text x="350" y="25" fill="#64f6c8" fontSize="16" fontWeight="bold" textAnchor="middle">
            טבלת DP לתרמיל - W=8, 4 פריטים
          </text>

          {/* כותרות עמודות - קיבולת */}
          <text x="60" y="65" fill="#a78bfa" fontSize="12" fontWeight="bold" textAnchor="middle">w→</text>
          {[0,1,2,3,4,5,6,7,8].map((w, idx) => (
            <text key={w} x={120 + idx * 65} y="65" fill="#a78bfa" fontSize="12" fontWeight="bold" textAnchor="middle">
              {w}
            </text>
          ))}

          {/* שורות */}
          {[
            { i: 0, label: '0', values: [0,0,0,0,0,0,0,0,0] },
            { i: 1, label: '1 (w=2,v=3)', values: [0,0,3,3,3,3,3,3,3] },
            { i: 2, label: '2 (w=3,v=4)', values: [0,0,3,4,4,7,7,7,7] },
            { i: 3, label: '3 (w=4,v=5)', values: [0,0,3,4,5,7,8,9,9] },
            { i: 4, label: '4 (w=5,v=6)', values: [0,0,3,4,5,7,8,9,10] }
          ].map((row, rowIdx) => (
            <g key={row.i}>
              <text x="60" y={105 + rowIdx * 50} fill="#fbbf24" fontSize="11" fontWeight="bold" textAnchor="middle">
                {row.label}
              </text>
              {row.values.map((val, colIdx) => (
                <g key={colIdx}>
                  <rect 
                    x={90 + colIdx * 65} 
                    y={85 + rowIdx * 50} 
                    width={60} 
                    height={40} 
                    fill={val > 0 ? "rgba(100, 246, 200, 0.2)" : "rgba(255,255,255,0.05)"} 
                    stroke={val > 0 ? "#64f6c8" : "#3d4d6b"} 
                    strokeWidth="1.5" 
                    rx="4"
                  />
                  <text 
                    x={120 + colIdx * 65} 
                    y={110 + rowIdx * 50} 
                    fill={val > 0 ? "#fbbf24" : "#666"} 
                    fontSize="13" 
                    fontWeight="bold" 
                    textAnchor="middle"
                  >
                    {val}
                  </text>
                </g>
              ))}
            </g>
          ))}

          {/* סימון התשובה */}
          <rect 
            x={90 + 8 * 65} 
            y={85 + 4 * 50} 
            width={60} 
            height={40} 
            fill="none" 
            stroke="#f97316" 
            strokeWidth="3" 
            rx="4"
          />
          <text x="600" y="350" fill="#f97316" fontSize="13" fontWeight="bold" textAnchor="middle">
            ← התשובה!
          </text>

          {/* הסבר */}
          <text x="350" y="380" fill="#64f6c8" fontSize="11" textAnchor="middle">
            dp[4][8] = 10 = הערך המקסימלי עם 4 פריטים וקיבולת 8
          </text>
        </svg>
      </div>

      <p>
        <strong>שחזור הפתרון:</strong>
      </p>
      <p>
        איך נדע <em>אילו</em> פריטים לקחנו? נתחיל מ-dp[n][W] ונחזור אחורה:
      </p>
      <ul>
        <li>אם dp[i][w] == dp[i-1][w], לא לקחנו את פריט i → עבור ל-dp[i-1][w]</li>
        <li>אחרת, לקחנו את פריט i → סמן אותו, עבור ל-dp[i-1][w-weight[i]]</li>
      </ul>

      <p>
        <strong>סיבוכיות:</strong>
      </p>
      <ul>
        <li><strong>זמן:</strong> O(n × W) - מילאנו טבלה בגודל n×W, כל תא O(1)</li>
        <li><strong>זיכרון:</strong> O(n × W) - אפשר לשפר ל-O(W) עם rolling array!</li>
      </ul>

      <p>
        <strong>הערה חשובה:</strong>
      </p>
      <p>
        זו <strong>לא</strong> סיבוכיות פולינומית אמיתית! W יכול להיות מספר גדול מאוד 
        (למשל 10⁹), והסיבוכיות תלויה ב<em>גודל</em> של W, לא במספר הביטים שלו. 
        זה נקרא <strong>Pseudo-Polynomial</strong>.
      </p>
    </article>
  </div>
</section>

<section id="lcs-example" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">דוגמה 3: תת-רצף משותף ארוך ביותר</p>
    <h2>Longest Common Subsequence (LCS)</h2>
  </header>

  <section className="conceptGrid">
    <article className="conceptCard conceptCard--explain">
      <p className="conceptCard__label">הבעיה</p>
      <h3 className="conceptCard__title">מה מחפשים?</h3>
      <p className="conceptCard__body">
        נתונות שתי מחרוזות. מצא את <strong>תת-הרצף המשותף הארוך ביותר</strong>.
        
        <strong>תת-רצף:</strong> תווים באותו סדר, אבל לא חייבים להיות רצופים.
        
        <strong>דוגמה:</strong>
        
        s1 = "ABCDGH"
        
        s2 = "AEDFHR"
        
        LCS = "ADH" (אורך 3)
      </p>
    </article>
    <article className="conceptCard conceptCard--algorithm">
      <p className="conceptCard__label">הגדרת מצב</p>
      <h3 className="conceptCard__title">מה dp[i][j] מייצג?</h3>
      <p className="conceptCard__body">
        dp[i][j] = אורך ה-LCS של:
        
        • i התווים הראשונים מ-s1
        
        • j התווים הראשונים מ-s2
        
        <strong>בסיסים:</strong>
        
        • dp[0][j] = 0 (מחרוזת ריקה)
        
        • dp[i][0] = 0 (מחרוזת ריקה)
      </p>
    </article>
    <article className="conceptCard conceptCard--solution">
      <p className="conceptCard__label">מעבר</p>
      <h3 className="conceptCard__title">נוסחת הרקורסיה</h3>
      <p className="conceptCard__body">
        <strong>אם s1[i] == s2[j]:</strong>
        
        dp[i][j] = dp[i-1][j-1] + 1
        
        <strong>אחרת:</strong>
        
        dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        <strong>סיבוכיות:</strong> O(n×m) זמן וזיכרון
      </p>
    </article>
  </section>

  <div style={{ marginTop: '2rem' }}>
    <h3 style={{ textAlign: 'center', marginBottom: '1.5rem', color: '#64f6c8' }}>📊 טבלת DP למציאת LCS</h3>
    <div style={{ display: 'flex', justifyContent: 'center' }}>
      <svg viewBox="0 0 450 440" style={{ width: '100%', maxWidth: '700px', height: 'auto', background: 'rgba(0,0,0,0.2)', borderRadius: '12px', padding: '1rem' }}>
        <text x="225" y="25" fill="#64f6c8" fontSize="16" fontWeight="bold" textAnchor="middle">
          LCS: "ABCDGH" ו-"AEDFHR"
        </text>
        <rect x="10" y="35" width="430" height="2" fill="#64f6c8" opacity="0.3" />

        {/* המחרוזות */}
        <text x="225" y="60" fill="#fbbf24" fontSize="13" textAnchor="middle">
          תת-רצף משותף: A D H (אורך 3)
        </text>

        {/* טבלת DP */}
        <g transform="translate(40, 80)">
          <text x="25" y="15" fill="#a78bfa" fontSize="11" fontWeight="bold" textAnchor="middle">ε</text>
          {['A','E','D','F','H','R'].map((char, idx) => (
            <text key={idx} x={65 + idx * 50} y="15" fill="#a78bfa" fontSize="11" fontWeight="bold" textAnchor="middle">
              {char}
            </text>
          ))}

          {[
            { char: 'ε', values: [0,0,0,0,0,0,0] },
            { char: 'A', values: [0,1,1,1,1,1,1] },
            { char: 'B', values: [0,1,1,1,1,1,1] },
            { char: 'C', values: [0,1,1,1,1,1,1] },
            { char: 'D', values: [0,1,1,2,2,2,2] },
            { char: 'G', values: [0,1,1,2,2,2,2] },
            { char: 'H', values: [0,1,1,2,2,3,3] }
          ].map((row, rowIdx) => (
            <g key={rowIdx}>
              <text x="-5" y={50 + rowIdx * 45} fill="#fbbf24" fontSize="11" fontWeight="bold" textAnchor="middle">
                {row.char}
              </text>
              {row.values.map((val, colIdx) => (
                <g key={colIdx}>
                  <rect 
                    x={15 + colIdx * 50} 
                    y={30 + rowIdx * 45} 
                    width={45} 
                    height={40} 
                    fill={val > 0 ? "rgba(167, 139, 250, 0.2)" : "rgba(255,255,255,0.05)"} 
                    stroke={val > 0 ? "#a78bfa" : "#3d4d6b"} 
                    strokeWidth="1.5" 
                    rx="4"
                  />
                  <text 
                    x={37 + colIdx * 50} 
                    y={55 + rowIdx * 45} 
                    fill={val > 0 ? "#fbbf24" : "#666"} 
                    fontSize="13" 
                    fontWeight="bold" 
                    textAnchor="middle"
                  >
                    {val}
                  </text>
                </g>
              ))}
            </g>
          ))}

          {/* סימון תשובה */}
          <rect 
            x={15 + 6 * 50} 
            y={30 + 6 * 45} 
            width={45} 
            height={40} 
            fill="none" 
            stroke="#f97316" 
            strokeWidth="3" 
            rx="4"
          />
        </g>

        {/* תוצאה */}
        <text x="225" y="420" fill="#64f6c8" fontSize="14" fontWeight="bold" textAnchor="middle">
          dp[6][6] = 3 ← אורך ה-LCS
        </text>
      </svg>
    </div>
    
    {/* תיבת נוסחת המעבר - מחוץ ל-SVG */}
    <div style={{ 
      maxWidth: '700px', 
      margin: '1.5rem auto', 
      padding: '1.5rem', 
      background: 'rgba(167, 139, 250, 0.1)', 
      border: '2px solid #a78bfa', 
      borderRadius: '12px',
      textAlign: 'center'
    }}>
      <h4 style={{ color: '#a78bfa', marginBottom: '1rem', fontSize: '1.1rem' }}>📝 נוסחת המעבר</h4>
      <p style={{ color: '#64f6c8', marginBottom: '0.5rem', fontSize: '1rem' }}>
        <strong>אם התווים שווים:</strong> dp[i][j] = dp[i-1][j-1] + 1
      </p>
      <p style={{ color: '#fbbf24', fontSize: '1rem', marginBottom: '0' }}>
        <strong>אחרת:</strong> dp[i][j] = max(dp[i-1][j], dp[i][j-1])
      </p>
    </div>
  </div>
</section>

<section id="matrix-chain-example" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">דוגמה 4: כפל שרשרת מטריצות</p>
    <h2>Matrix Chain Multiplication - אופטימיזציה של סדר כפל</h2>
  </header>

  <section className="conceptGrid">
    <article className="conceptCard conceptCard--explain">
      <p className="conceptCard__label">הבעיה</p>
      <h3 className="conceptCard__title">מה מחפשים?</h3>
      <p className="conceptCard__body">
        נתונות n מטריצות לכפל. <strong>סדר הכפל משפיע על מספר הפעולות!</strong>
        
        <strong>דוגמה:</strong>
        
        A₁: 10×20, A₂: 20×30, A₃: 30×40
       
        כפל p×q ו-q×r דורש p×q×r פעולות.
      </p>
    </article>
    <article className="conceptCard conceptCard--important">
      <p className="conceptCard__label">ההבדל</p>
      <h3 className="conceptCard__title">למה זה משנה?</h3>
      <p className="conceptCard__body">
        <strong>(A₁×A₂)×A₃:</strong>
      
        6,000 + 12,000 = 18,000 פעולות ✓
 
        <strong>A₁×(A₂×A₃):</strong>
      
        24,000 + 8,000 = 32,000 פעולות ✗
     
        הפרש של כמעט 50%!
      </p>
    </article>
    <article className="conceptCard conceptCard--algorithm">
      <p className="conceptCard__label">הגדרת מצב</p>
      <h3 className="conceptCard__title">מה dp[i][j] מייצג?</h3>
      <p className="conceptCard__body">
        dp[i][j] = <strong>מספר הפעולות המינימלי</strong> לכפל מטריצות Aᵢ עד Aⱼ.
        
        <strong>בסיסים:</strong>
       
        dp[i][i] = 0 (מטריצה אחת, אין כפל)
     
        <strong>סיבוכיות:</strong> O(n³) זמן, O(n²) זיכרון
      </p>
    </article>
    <article className="conceptCard conceptCard--solution">
      <p className="conceptCard__label">מעבר</p>
      <h3 className="conceptCard__title">נוסחת הרקורסיה</h3>
      <p className="conceptCard__body">
        בוחרים נקודת חלוקה k:
    
        <strong style={{ direction: 'ltr', display: 'block', textAlign: 'center' }}>
          dp[i][j] = min(dp[i][k] + dp[k+1][j] + pᵢ₋₁×pₖ×pⱼ)
        </strong>
       
        עבור כל k מ-i עד j-1
       
        <strong>סדר מילוי:</strong> לפי אורך טווח
      </p>
    </article>
  </section>

  <div style={{ marginTop: '2rem' }}>
    <h3 style={{ textAlign: 'center', marginBottom: '1.5rem', color: '#64f6c8' }}>📊 השוואת סדרי כפל</h3>
    
    {/* דרך 1 - לא אופטימלי */}
    <div style={{ 
      maxWidth: '600px', 
      margin: '1rem auto', 
      padding: '1.5rem', 
      background: 'rgba(249, 115, 22, 0.1)', 
      border: '2px solid #f97316', 
      borderRadius: '12px'
    }}>
      <h4 style={{ color: '#f97316', marginBottom: '1rem', textAlign: 'center' }}>
        ❌ דרך 1: ((A₁×A₂)×A₃)×A₄
      </h4>
      <ul style={{ color: '#fbbf24', listStyle: 'none', padding: 0, margin: 0 }}>
        <li style={{ marginBottom: '0.5rem' }}>שלב 1: A₁×A₂ (10×20×30) = <strong>6,000</strong></li>
        <li style={{ marginBottom: '0.5rem' }}>שלב 2: (A₁A₂)×A₃ (10×30×40) = <strong>12,000</strong></li>
        <li style={{ marginBottom: '0.5rem' }}>שלב 3: ((A₁A₂)A₃)×A₄ (10×40×30) = <strong>12,000</strong></li>
      </ul>
      <p style={{ color: '#f97316', fontWeight: 'bold', marginTop: '1rem', marginBottom: 0, textAlign: 'center', fontSize: '1.1rem' }}>
        סה"כ: 30,000 פעולות
      </p>
    </div>

    {/* חץ */}
    <div style={{ textAlign: 'center', fontSize: '2rem', color: '#64f6c8', margin: '0.5rem 0' }}>↓</div>

    {/* דרך 2 - אופטימלי */}
    <div style={{ 
      maxWidth: '600px', 
      margin: '1rem auto', 
      padding: '1.5rem', 
      background: 'rgba(100, 246, 200, 0.1)', 
      border: '2px solid #64f6c8', 
      borderRadius: '12px'
    }}>
      <h4 style={{ color: '#64f6c8', marginBottom: '1rem', textAlign: 'center' }}>
        ✓ דרך 2: (A₁×(A₂×A₃))×A₄
      </h4>
      <ul style={{ color: '#fbbf24', listStyle: 'none', padding: 0, margin: 0 }}>
        <li style={{ marginBottom: '0.5rem' }}>שלב 1: A₂×A₃ (20×30×40) = <strong>24,000</strong></li>
        <li style={{ marginBottom: '0.5rem' }}>שלב 2: A₁×(A₂A₃) (10×20×40) = <strong>8,000</strong></li>
        <li style={{ marginBottom: '0.5rem' }}>שלב 3: (A₁(A₂A₃))×A₄ (10×40×30) = <strong>12,000</strong></li>
      </ul>
      <p style={{ color: '#64f6c8', fontWeight: 'bold', marginTop: '1rem', marginBottom: 0, textAlign: 'center', fontSize: '1.1rem' }}>
        סה"כ: 44,000 פעולות
      </p>
    </div>

    {/* סיכום */}
    <div style={{ 
      maxWidth: '400px', 
      margin: '1.5rem auto', 
      padding: '1rem', 
      background: 'rgba(167, 139, 250, 0.1)', 
      border: '2px solid #a78bfa', 
      borderRadius: '12px',
      textAlign: 'center'
    }}>
      <p style={{ color: '#a78bfa', fontWeight: 'bold', margin: 0, fontSize: '1.1rem' }}>
        🎯 הפרש: 14,000 פעולות (46% יותר!)
      </p>
    </div>

    {/* נוסחת המעבר */}
    <div style={{ 
      maxWidth: '500px', 
      margin: '1.5rem auto', 
      padding: '1.5rem', 
      background: 'rgba(100, 246, 200, 0.1)', 
      border: '2px solid #64f6c8', 
      borderRadius: '12px',
      textAlign: 'center'
    }}>
      <h4 style={{ color: '#64f6c8', marginBottom: '1rem', fontSize: '1.1rem' }}>📝 נוסחת המעבר</h4>
      <p style={{ color: '#fbbf24', fontSize: '1rem', marginBottom: '0.5rem', direction: 'ltr' }}>
        <strong>dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]×p[k]×p[j])</strong>
      </p>
      <p style={{ color: '#a78bfa', fontSize: '0.9rem', marginBottom: 0 }}>
        עבור כל k מ-i עד j-1
      </p>
    </div>

    {/* טבלת DP */}
    <h4 style={{ textAlign: 'center', marginTop: '2rem', marginBottom: '1rem', color: '#a78bfa' }}>
      📊 טבלת DP: מילוי צעד אחר צעד
    </h4>
    <p style={{ textAlign: 'center', color: '#888', marginBottom: '1rem', fontSize: '0.9rem' }}>
      מימדי המטריצות: p = [10, 20, 30, 40, 30] → A₁(10×20), A₂(20×30), A₃(30×40), A₄(40×30)
    </p>
    
    <div style={{ overflowX: 'auto' }}>
      <table style={{ 
        margin: '0 auto', 
        borderCollapse: 'collapse', 
        background: 'rgba(0,0,0,0.2)',
        borderRadius: '8px'
      }}>
        <thead>
          <tr>
            <th style={{ padding: '12px 20px', color: '#a78bfa', borderBottom: '2px solid #a78bfa' }}>i \ j</th>
            <th style={{ padding: '12px 20px', color: '#a78bfa', borderBottom: '2px solid #a78bfa' }}>1</th>
            <th style={{ padding: '12px 20px', color: '#a78bfa', borderBottom: '2px solid #a78bfa' }}>2</th>
            <th style={{ padding: '12px 20px', color: '#a78bfa', borderBottom: '2px solid #a78bfa' }}>3</th>
            <th style={{ padding: '12px 20px', color: '#a78bfa', borderBottom: '2px solid #a78bfa' }}>4</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style={{ padding: '12px 20px', color: '#fbbf24', fontWeight: 'bold' }}>1</td>
            <td style={{ padding: '12px 20px', color: '#666', textAlign: 'center' }}>0</td>
            <td style={{ padding: '12px 20px', color: '#64f6c8', textAlign: 'center' }}>6,000</td>
            <td style={{ padding: '12px 20px', color: '#64f6c8', textAlign: 'center' }}>18,000</td>
            <td style={{ padding: '12px 20px', color: '#f97316', textAlign: 'center', fontWeight: 'bold', border: '2px solid #f97316', borderRadius: '4px' }}>30,000</td>
          </tr>
          <tr>
            <td style={{ padding: '12px 20px', color: '#fbbf24', fontWeight: 'bold' }}>2</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#666', textAlign: 'center' }}>0</td>
            <td style={{ padding: '12px 20px', color: '#64f6c8', textAlign: 'center' }}>24,000</td>
            <td style={{ padding: '12px 20px', color: '#64f6c8', textAlign: 'center' }}>32,000</td>
          </tr>
          <tr>
            <td style={{ padding: '12px 20px', color: '#fbbf24', fontWeight: 'bold' }}>3</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#666', textAlign: 'center' }}>0</td>
            <td style={{ padding: '12px 20px', color: '#64f6c8', textAlign: 'center' }}>36,000</td>
          </tr>
          <tr>
            <td style={{ padding: '12px 20px', color: '#fbbf24', fontWeight: 'bold' }}>4</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#3d4d6b', textAlign: 'center' }}>-</td>
            <td style={{ padding: '12px 20px', color: '#666', textAlign: 'center' }}>0</td>
          </tr>
        </tbody>
      </table>
    </div>

    {/* הסבר מילוי */}
    <div style={{ 
      maxWidth: '600px', 
      margin: '1.5rem auto', 
      padding: '1.5rem', 
      background: 'rgba(167, 139, 250, 0.1)', 
      border: '2px solid #a78bfa', 
      borderRadius: '12px'
    }}>
      <h4 style={{ color: '#a78bfa', marginBottom: '1rem', textAlign: 'center' }}>🔢 סדר המילוי</h4>
      <ul style={{ color: '#ccc', margin: 0, paddingRight: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <strong style={{ color: '#666' }}>אלכסון ראשי (len=1):</strong> dp[i][i] = 0 (אין כפל)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <strong style={{ color: '#64f6c8' }}>len=2:</strong> dp[1][2] = 10×20×30 = <strong>6,000</strong>
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <strong style={{ color: '#64f6c8' }}>len=3:</strong> dp[1][3] = min(dp[1][1]+dp[2][3]+10×20×40, dp[1][2]+dp[3][3]+10×30×40) = min(8000+0, 6000+12000) = <strong>18,000</strong>
        </li>
        <li style={{ marginBottom: '0' }}>
          <strong style={{ color: '#f97316' }}>len=4:</strong> dp[1][4] = התשובה הסופית = <strong>30,000</strong>
        </li>
      </ul>
    </div>
  </div>
</section>


<section id="common-patterns" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">תבניות נפוצות</p>
    <h2>סוגי בעיות DP קלאסיות</h2>
  </header>
  <div className="greedyDoc__media">
    <article>
      <h3>1. בעיות על מחרוזות</h3>
      <ul>
        <li><strong>LCS:</strong> תת-רצף משותף ארוך ביותר</li>
        <li><strong>Edit Distance (Levenshtein):</strong> מספר מינימלי של עריכות</li>
        <li><strong>Longest Palindromic Subsequence:</strong> תת-רצף פלינדרומי ארוך ביותר</li>
        <li><strong>String Matching:</strong> האם s1 תת-רצף של s2?</li>
      </ul>
      <p>
        <strong>מאפיין משותף:</strong> טבלה דו-ממדית dp[i][j] שמשווה תחיליות של שתי מחרוזות.
      </p>

      <h3>2. בעיות תרמיל (Knapsack)</h3>
      <ul>
        <li><strong>0/1 Knapsack:</strong> כל פריט פעם אחת לכל היותר</li>
        <li><strong>Unbounded Knapsack:</strong> כל פריט ללא הגבלה</li>
        <li><strong>Subset Sum:</strong> האם קיימת תת-קבוצה עם סכום נתון?</li>
        <li><strong>Partition:</strong> חלוקה לשני חלקים שווים</li>
      </ul>
      <p>
        <strong>מאפיין משותף:</strong> dp[i][w] עם בחירה בינארית (לקחת/לא לקחת).
      </p>

      <h3>3. בעיות על מסלולים</h3>
      <ul>
        <li><strong>Grid Paths:</strong> מספר מסלולים מ-(0,0) ל-(n,m)</li>
        <li><strong>Minimum Path Sum:</strong> מסלול מינימלי בגריד עם משקלים</li>
        <li><strong>Triangle:</strong> מסלול מינימלי במשולש מספרים</li>
        <li><strong>Longest Increasing Path:</strong> מסלול עולה ארוך ביותר</li>
      </ul>
      <p>
        <strong>מאפיין משותף:</strong> dp[i][j] = מסלול טוב ביותר למיקום (i,j).
      </p>

      <h3>4. בעיות על רצפים</h3>
      <ul>
        <li><strong>LIS:</strong> תת-רצף עולה ארוך ביותר (Longest Increasing Subsequence)</li>
        <li><strong>Maximum Subarray Sum (Kadane):</strong> תת-מערך עם סכום מקסימלי</li>
        <li><strong>Stock Buy/Sell:</strong> מקסום רווח במניות</li>
        <li><strong>House Robber:</strong> מקסום רווח בבחירה לא רצופה</li>
      </ul>
      <p>
        <strong>מאפיין משותף:</strong> dp[i] תלוי רק ב-dp[i-1], dp[i-2] וכו'.
      </p>

      <h3>5. בעיות על מבנים</h3>
      <ul>
        <li><strong>Matrix Chain Multiplication:</strong> סדר כפל מטריצות אופטימלי</li>
        <li><strong>Optimal BST:</strong> עץ חיפוש בינארי אופטימלי</li>
        <li><strong>Partition DP:</strong> חלוקה למקטעים אופטימליים</li>
        <li><strong>Egg Drop:</strong> מספר מינימלי של זריקות ביצים</li>
      </ul>
      <p>
        <strong>מאפיין משותף:</strong> dp[i][j] = תת-בעיה על טווח [i, j].
      </p>
    </article>
  </div>
</section>

<section id="optimization-tricks" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">אופטימיזציות</p>
    <h2>איך לשפר ביצועים?</h2>
  </header>
  <div className="conceptGrid">
    <article className="conceptCard conceptCard--insight">
      <p className="conceptCard__label">זיכרון</p>
      <h3 className="conceptCard__title">Rolling Array / Space Optimization</h3>
      <p className="conceptCard__body">
        אם dp[i] תלוי רק ב-dp[i-1] (או ב-dp[i-1] ו-dp[i-2]), אין צורך לשמור את כל הטבלה!
        <br/><br/>
        <strong>דוגמה פיבונאצ'י:</strong>
        <br/>
        במקום מערך dp[], השתמש בשני משתנים prev1 ו-prev2.
        <br/>
        זיכרון: O(n) → O(1)
        <br/><br/>
        <strong>דוגמה תרמיל:</strong>
        <br/>
        במקום dp[n][W], השתמש בשני מערכים בגודל W.
        <br/>
        זיכרון: O(n×W) → O(W)
      </p>
    </article>

    <article className="conceptCard conceptCard--insight">
      <p className="conceptCard__label">זמן</p>
      <h3 className="conceptCard__title">Memoization עם Hash Map</h3>
      <p className="conceptCard__body">
        אם המצבים האפשריים נדירים (sparse state space), השתמש ב-hash map במקום מערך.
        <br/><br/>
        <strong>למשל:</strong> אם רק חלק קטן מהמצבים באמת מתרחשים, אין סיבה להקצות מערך ענק.
        <br/><br/>
        Python: dict, C++: unordered_map, Java: HashMap
      </p>
    </article>

    <article className="conceptCard conceptCard--important">
      <p className="conceptCard__label">טכניקה</p>
      <h3 className="conceptCard__title">State Reduction</h3>
      <p className="conceptCard__body">
        לפעמים אפשר להפחית את מספר הממדים במצב.
        <br/><br/>
        <strong>דוגמה:</strong> במקום dp[i][j][k], חשוב אם ניתן לבטא k באמצעות i ו-j.
        <br/>
        אם k = i + j, אז dp[i][j] מספיק!
      </p>
    </article>

    <article className="conceptCard conceptCard--important">
      <p className="conceptCard__label">מתקדם</p>
      <h3 className="conceptCard__title">DP על עצים / גרפים</h3>
      <p className="conceptCard__body">
        DP לא רק על מערכים! אפשר להריץ DP על עצים (Tree DP) או גרפים (DP + BFS/DFS).
        <br/><br/>
        <strong>דוגמה:</strong> מציאת קוטר העץ, מספר מקסימלי של צמתים עצמאיים, צביעה מינימלית.
      </p>
    </article>
  </div>
</section>

<section id="summary" className="greedyDoc__section container">
  <header>
    <p className="greedyDoc__eyebrow">סיום</p>
    <h2>סיכום כולל</h2>
  </header>
  <article style={{ lineHeight: '1.8', fontSize: '1.05em' }}>
    <h3 style={{ color: '#64f6c8', borderBottom: '3px solid #64f6c8', paddingBottom: '0.5rem', marginBottom: '1rem' }}>
      תכנון דינמי - המהות
    </h3>
    <p style={{ 
      padding: '1rem', 
      background: 'rgba(13, 139, 212, 0.08)', 
      borderRadius: '8px', 
      borderLeft: '4px solid #0d8bd4' 
    }}>
      תכנון דינמי הוא טכניקה לפתרון בעיות אופטימיזציה על ידי <strong style={{ color: '#0d8bd4' }}>
      פירוק לתתי-בעיות חופפות</strong> ו<strong style={{ color: '#088a7b' }}>שמירת תוצאות 
      לשימוש חוזר</strong>. במקום לפתור אותה תת-בעיה שוב ושוב, אנחנו פותרים כל תת-בעיה 
      פעם אחת ושומרים את התוצאה. כך הופכים פתרונות אקספוננציאליים O(2ⁿ) לפולינומיים O(n²) או טוב יותר.
    </p>

    <h3 style={{ 
      color: '#fbbf24', 
      borderBottom: '3px solid #fbbf24', 
      paddingBottom: '0.5rem', 
      marginTop: '2.5rem', 
      marginBottom: '1rem' 
    }}>
      שלושת העקרונות
    </h3>
    <div style={{ 
      display: 'grid', 
      gridTemplateColumns: '1fr 1fr 1fr', 
      gap: '1.5rem', 
      marginTop: '1.5rem' 
    }}>
      <div style={{ 
        background: 'var(--greedy-section-bg)', 
        padding: '1.5rem', 
        borderRadius: '12px', 
        borderTop: '4px solid #0d8bd4' 
      }}>
        <h4 style={{ color: '#0d8bd4', margin: '0 0 0.8rem 0' }}>
          ① תתי-בעיות חופפות
        </h4>
        <p style={{ margin: 0, fontSize: '0.95em' }}>
          אותן תתי-בעיות חוזרות שוב ושוב. במקום לפתור כל פעם מחדש, נשמור את התוצאה בטבלה.
        </p>
        <p style={{ margin: '0.8rem 0 0', fontSize: '0.95em' }}>
          <strong style={{ color: '#0d8bd4' }}>דוגמה:</strong> F(3) מחושב פעמיים בפיבונאצ'י נאיבי
        </p>
      </div>

      <div style={{ 
        background: 'var(--greedy-section-bg)', 
        padding: '1.5rem', 
        borderRadius: '12px', 
        borderTop: '4px solid #64f6c8' 
      }}>
        <h4 style={{ color: '#64f6c8', margin: '0 0 0.8rem 0' }}>
          ② מבנה אופטימלי
        </h4>
        <p style={{ margin: 0, fontSize: '0.95em' }}>
          הפתרון האופטימלי לבעיה בנוי מפתרונות אופטימליים לתתי-בעיות. זה מאפשר לנו לבנות את הפתרון 
          הכולל מלמטה למעלה.
        </p>
        <p style={{ margin: '0.8rem 0 0', fontSize: '0.95em' }}>
          <strong style={{ color: '#64f6c8' }}>דוגמה:</strong> LCS אופטימלי = בחירה טובה + LCS קטן יותר
        </p>
      </div>

      <div style={{ 
        background: 'var(--greedy-section-bg)', 
        padding: '1.5rem', 
        borderRadius: '12px', 
        borderTop: '4px solid #fbbf24' 
      }}>
        <h4 style={{ color: '#fbbf24', margin: '0 0 0.8rem 0' }}>
          ③ שמירה וזיכרון
        </h4>
        <p style={{ margin: 0, fontSize: '0.95em' }}>
          כל תוצאה שחושבה נשמרת בטבלה (memoization) ונמשכת בעתיד. זה הופך חישוב אקספוננציאלי 
          לפולינומי.
        </p>
        <p style={{ margin: '0.8rem 0 0', fontSize: '0.95em' }}>
          <strong style={{ color: '#fbbf24' }}>מחיר:</strong> זיכרון נוסף, אבל שווה את זה!
        </p>
      </div>
    </div>

    <h3 style={{ 
      color: '#a78bfa', 
      borderBottom: '3px solid #a78bfa', 
      paddingBottom: '0.5rem', 
      marginTop: '2.5rem', 
      marginBottom: '1rem' 
    }}>
      נקודות קריטיות
    </h3>
    <ul style={{ lineHeight: '2' }}>
      <li style={{ 
        padding: '0.8rem', 
        marginBottom: '0.8rem', 
        background: 'rgba(255, 179, 71, 0.08)', 
        borderLeft: '4px solid #ffb347', 
        borderRadius: '4px' 
      }}>
        <strong style={{ color: '#ff8c42' }}>✓ הגדרת מצב ברורה:</strong> מה dp[state] מייצג? 
        הגדרה לא ברורה = קוד שגוי. כתוב את ההגדרה בהערה!
      </li>
      <li style={{ 
        padding: '0.8rem', 
        marginBottom: '0.8rem', 
        background: 'rgba(100, 246, 200, 0.08)', 
        borderLeft: '4px solid #64f6c8', 
        borderRadius: '4px' 
      }}>
        <strong style={{ color: '#00d9a3' }}>✓ מעבר נכון:</strong> הקשר בין המצב הנוכחי למצבים 
        קודמים הוא הלב של DP. בדוק על דוגמאות קטנות!
      </li>
      <li style={{ 
        padding: '0.8rem', 
        marginBottom: '0.8rem', 
        background: 'rgba(251, 191, 36, 0.08)', 
        borderLeft: '4px solid #fbbf24', 
        borderRadius: '4px' 
      }}>
        <strong style={{ color: '#fbbf24' }}>✓ בסיסים:</strong> תנאי הקצה חייבים להיות נכונים! 
        בסיסים שגויים → כל הטבלה שגויה.
      </li>
      <li style={{ 
        padding: '0.8rem', 
        marginBottom: '0.8rem', 
        background: 'rgba(167, 139, 250, 0.08)', 
        borderLeft: '4px solid #a78bfa', 
        borderRadius: '4px' 
      }}>
        <strong style={{ color: '#a78bfa' }}>✓ סדר מילוי:</strong> בגישת Bottom-Up, ודא שכל תא 
        שאתה צריך כבר חושב לפני שאתה משתמש בו!
      </li>
      <li style={{ 
        padding: '0.8rem', 
        marginBottom: '0.8rem', 
        background: 'rgba(236, 72, 153, 0.08)', 
        borderLeft: '4px solid #ec4899', 
        borderRadius: '4px' 
      }}>
        <strong style={{ color: '#ec4899' }}>✓ שחזור פתרון:</strong> לפעמים צריך לא רק את הערך 
        האופטימלי, אלא גם את הבחירות עצמן. שמור מצביעים או עשה backtracking!
      </li>
    </ul>

    <h3 style={{ 
      color: '#64f6c8', 
      borderBottom: '3px solid #64f6c8', 
      paddingBottom: '0.5rem', 
      marginTop: '2.5rem', 
      marginBottom: '1rem' 
    }}>
      Top-Down vs Bottom-Up
    </h3>
    <div style={{ 
      display: 'grid', 
      gridTemplateColumns: '1fr 1fr', 
      gap: '1.5rem', 
      marginTop: '1.5rem' 
    }}>
      <div style={{ 
        background: 'rgba(167, 139, 250, 0.1)', 
        padding: '1.5rem', 
        borderRadius: '12px', 
        borderLeft: '4px solid #a78bfa' 
      }}>
        <h4 style={{ color: '#a78bfa', margin: '0 0 0.8rem 0' }}>Top-Down (Memoization)</h4>
        <p style={{ margin: '0 0 0.8rem 0', fontSize: '0.95em' }}>
          רקורסיה + טבלת זיכרון. אוטומטית פותר רק תתי-בעיות שבאמת צריך.
        </p>
        <ul style={{ margin: 0, paddingRight: '1.2rem', fontSize: '0.9em' }}>
          <li>קל יותר לכתוב (טבעי יותר)</li>
          <li>פותר רק מצבים נדרשים</li>
          <li>overhead של רקורסיה</li>
          <li>עלול לגרום ל-stack overflow</li>
        </ul>
      </div>

      <div style={{ 
        background: 'rgba(100, 246, 200, 0.1)', 
        padding: '1.5rem', 
        borderRadius: '12px', 
        borderLeft: '4px solid #64f6c8' 
      }}>
        <h4 style={{ color: '#64f6c8', margin: '0 0 0.8rem 0' }}>Bottom-Up (Tabulation)</h4>
        <p style={{ margin: '0 0 0.8rem 0', fontSize: '0.95em' }}>
          מילוי טבלה איטרטיבי. מתחיל מהבסיסים ובונה את הפתרון למעלה.
        </p>
        <ul style={{ margin: 0, paddingRight: '1.2rem', fontSize: '0.9em' }}>
          <li>מהיר יותר (אין overhead)</li>
          <li>קל יותר לאופטמז זיכרון</li>
          <li>דורש חשיבה על סדר מילוי</li>
          <li>עלול לחשב מצבים מיותרים</li>
        </ul>
      </div>
    </div>

    <p style={{ 
      marginTop: '1.5rem', 
      padding: '1rem', 
      background: 'rgba(100, 246, 200, 0.08)', 
      borderRadius: '8px', 
      borderLeft: '4px solid var(--greedy-section-title)' 
    }}>
      <strong>לסיכום:</strong> תכנון דינמי הוא אחת הטכניקות החזקות ביותר במדעי המחשב. 
      היא הופכת בעיות שנראות בלתי פתירות (O(2ⁿ)) לפתירות (O(n²) או טוב יותר). 
      המפתח להצלחה: הגדרת מצב ברורה, מעבר נכון, בסיסים נכונים, וסדר מילוי תקין. 
      עם התרגול, תזהו בעיות DP במבט ראשון ותדעו בדיוק איך לפתור אותן!
    </p>
  </article>
</section>
